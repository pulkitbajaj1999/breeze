const fs = require('fs');
const path = require('path');



const METADATA = 
`[Script Info]
; Script generated by FFmpeg/Lavc58.134.100
ScriptType: v4.00+
PlayResX: 384
PlayResY: 288
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Road Rage,22,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,5,0,0,0,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text

`;

/**
 * Converts a simple subtitle file to a full .ass dialogue file
 * @param {string} filePath - Path to the .txt or .sub file
 * @returns {string} - The path to the newly created file
 */

/**
 * Adds seconds to a MM:SS string and returns H:MM:SS.00
 * @param {string} timeStr - Format "MM:SS"
 * @param {number} offsetSeconds - Seconds to add (e.g., 10)
 * @returns {string} - Format "0:MM:SS.00"
 */
function offsetTimestamp(timeStr, offsetSeconds) {
  const [mins, secs] = timeStr.split(':').map(Number);
  
  // Calculate total seconds and handle the math
  let totalSeconds = (mins * 60) + secs + offsetSeconds;
  
  const h = Math.floor(totalSeconds / 3600);
  const m = Math.floor((totalSeconds % 3600) / 60);
  const s = totalSeconds % 60;

  // Format components to be 2 digits (except Hour)
  const mm = String(m).padStart(2, '0');
  const ss = String(s).padStart(2, '0');

  return `${h}:${mm}:${ss}.00`;
}

function processSubtitleFile(filePath) {
    if (!filePath) return
    // 1. Read the input file
    const rawContent = fs.readFileSync(filePath, 'utf-8');
    // 2. Define the .ass Metadata Header


    // 3. Conversion Logic
    const lines = rawContent.trim().split('\n').map(l => l.trim()).filter(l => l !== '');
    const entries = [];

    for (let i = 0; i < lines.length; i++) {
        if (/^\d{2}:\d{2}$/.test(lines[i])) {
            entries.push({
                startTime: lines[i],
                text: lines[i + 1] ? lines[i + 1] : ""
            });
            i++; 
        }
    }

    const dialogueLines = entries.map((entry, index) => {
      const nextEntry = entries[index + 1];
      
      // Format the Start Time
      const start = `0:${entry.startTime}.00`;
      
      // Determine End Time
      let end;
      if (nextEntry) {
          // Option A: End exactly when the next starts
          end = `0:${nextEntry.startTime}.00`;
      } else {
          // Option B: Last line gets the 10-second boost
          end = offsetTimestamp(entry.startTime, 10);
      }
  
      const cleanText = entry.text.replace(/,\s*$/, '').replace(/,\s*/, '\\N');
      return `Dialogue: 0,${start},${end},Default,,0,0,0,,{\\fad(0,500)}${cleanText}`;
    }).join('\n');

    // 4. Combine Metadata and Dialogues
    const finalOutput = METADATA + dialogueLines;

    // 5. Create new file path (e.g., "song.txt" -> "song_converted.ass")
    const parsedPath = path.parse(filePath);
    const newPath = path.join(parsedPath.dir, `${parsedPath.name}_converted.ass`);

    // 6. Write to disk
    fs.writeFileSync(newPath, finalOutput);

    return newPath;
}

module.exports = processSubtitleFile

function test() {
  // Usage
  try {
      const resultPath = processSubtitleFile('./AUD-20240717-WA0039.txt');
      console.log(`Success! File created at: ${resultPath}`);
  } catch (err) {
      console.error("Error processing file:", err);
  }

}